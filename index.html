<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>速譯 (Gemini Translator)</title>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- React & ReactDOM -->
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@400;500;700&family=Noto+Serif+JP:wght@400;700&family=Noto+Serif+TC:wght@400;700&family=Noto+Serif:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">

    <style>
        body { font-family: 'Noto Sans TC', sans-serif; }
        .font-serif-custom { font-family: "Noto Serif TC", "Noto Serif JP", "Noto Serif", serif; }
        /* Custom scrollbar */
        ::-webkit-scrollbar { width: 10px; height: 10px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: rgba(255, 255, 255, 0.15); border-radius: 5px; }
        ::-webkit-scrollbar-thumb:hover { background: rgba(255, 255, 255, 0.3); }
        
        .fade-in { animation: fadeIn 0.3s ease-in-out; }
        @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }

        /* Loading Bar Animation */
        @keyframes loading-bar {
            0% { transform: translateX(-100%); }
            50% { transform: translateX(0%); }
            100% { transform: translateX(100%); }
        }
        .animate-loading-bar {
            animation: loading-bar 1.5s infinite linear;
        }

        /* Shimmer effect for skeleton */
        @keyframes shimmer {
            0% { background-position: -200% 0; }
            100% { background-position: 200% 0; }
        }
        .skeleton {
            background: linear-gradient(90deg, rgba(255,255,255,0.05) 25%, rgba(255,255,255,0.1) 50%, rgba(255,255,255,0.05) 75%);
            background-size: 200% 100%;
            animation: shimmer 1.5s infinite;
        }
    </style>
</head>
<body class="bg-neutral-950 text-neutral-200 overflow-hidden">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;

        // --- Configuration ---
        // 請將您的 API Key 填入下方引號中 (例如: "AIzaSy...")
        // 填入並儲存檔案後，下次開啟網頁就會直接讀取此處的 Key，不再跳出詢問視窗。
        const DEFAULT_API_KEY = ""; 

        // 定義模型優先順序列表：使用最新的 Gemini 模型並提供降級選項
        const MODEL_PRIORITY = ["gemini-2.0-flash-exp", "gemini-1.5-flash-002", "gemini-1.5-flash-latest", "gemini-1.5-flash"];

        const SERIF_FAMILY = '"Noto Serif TC", "Noto Serif JP", "Noto Serif", serif';
        
        const LANG_LABEL = {
            en: "英文",
            "zh-TW": "繁體中文",
            ja: "日文",
        };

        const LANG_COLOR = {
            en: "text-sky-200",
            "zh-TW": "text-amber-100",
            ja: "text-emerald-200",
        };

        const ALL_LANGS = ["en", "zh-TW", "ja"];

        function detectLanguage(text) {
            const jaRegex = /[\u3040-\u309F\u30A0-\u30FF]/;
            const zhRegex = /[\u4E00-\u9FFF]/;
            if (jaRegex.test(text)) return "ja";
            if (zhRegex.test(text)) return "zh-TW";
            return "en";
        }

        // --- Icons (Upscaled) ---
        const EyeIcon = () => (
            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z" />
            </svg>
        );
        const CopyIcon = () => (
            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M8 16H6a2 2 0 01-2-2V6a2 2 0 012-2h8a2 2 0 012 2v2m-6 12h8a2 2 0 002-2v-8a2 2 0 00-2-2h-8a2 2 0 00-2 2v8a2 2 0 002 2z" />
            </svg>
        );
        const TrashIcon = () => (
            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16" />
            </svg>
        );
        const SparklesIcon = ({ className }) => (
            <svg className={`w-5 h-5 ${className}`} fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M5 3v4M3 5h4M6 17v4m-2-2h4m5-16l2.286 6.857L21 12l-5.714 2.143L13 21l-2.286-6.857L5 12l5.714-2.143L13 3z" />
            </svg>
        );
        const KeyIcon = () => (
            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 7a2 2 0 012 2m4 0a6 6 0 01-7.743 5.743L11 17H9v2H7v2H4a1 1 0 01-1-1v-2.586a1 1 0 01.293-.707l5.964-5.964A6 6 0 1121 9z" />
            </svg>
        );
        const BookIcon = () => (
            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 6.253v13m0-13C10.832 5.477 9.246 5 7.5 5S4.168 5.477 3 6.253v13C4.168 18.477 5.754 18 7.5 18s3.332.477 4.5 1.253m0-13C13.168 5.477 14.754 5 16.5 5c1.747 0 3.332.477 4.5 1.253v13C19.832 18.477 18.247 18 16.5 18c-1.746 0-3.332.477-4.5 1.253" />
            </svg>
        );
        const UploadIcon = () => (
            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12" />
            </svg>
        );
        const PlusIcon = () => (
            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 4v16m8-8H4" />
            </svg>
        );
        const SpeakerIcon = () => (
            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15.536 8.464a5 5 0 010 7.072m2.828-9.9a9 9 0 010 12.728M5.586 15H4a1 1 0 01-1-1v-4a1 1 0 011-1h1.586l4.707-4.707C10.923 3.663 12 4.109 12 5v14c0 .891-1.077 1.337-1.707.707L5.586 15z" />
            </svg>
        );
        const StopIcon = () => (
            <svg className="w-5 h-5" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M9 10a1 1 0 011-1h4a1 1 0 011 1v4a1 1 0 01-1 1h-4a1 1 0 01-1-1v-4z" />
            </svg>
        );
        const LoadingSpinner = () => (
            <svg className="animate-spin h-6 w-6 text-blue-400" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle className="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" strokeWidth="4"></circle>
                <path className="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
        );

        // --- Helper Functions ---
        function formatGlossaryForPrompt(items) {
            if (!items || items.length === 0) return "";
            return items.map(item => {
                const parts = [];
                if (item.zh) parts.push(`[Zh]: "${item.zh}"`);
                if (item.ja) parts.push(`[Ja]: "${item.ja}"`);
                if (item.en) parts.push(`[En]: "${item.en}"`);
                if (item.abbr) parts.push(`(Abbr: "${item.abbr}")`);
                return parts.join(" | ");
            }).join("\n");
        }

        // --- Components ---
        const SkeletonLoader = () => (
            <div className="w-full h-full flex flex-col gap-6 animate-in fade-in duration-500 py-2">
                <div className="h-5 bg-white/5 rounded skeleton w-3/4"></div>
                <div className="h-5 bg-white/5 rounded skeleton w-full"></div>
                <div className="h-5 bg-white/5 rounded skeleton w-5/6"></div>
                <div className="h-5 bg-white/5 rounded skeleton w-4/5"></div>
            </div>
        );

        // --- Main Component ---
        function App() {
            // User API Key State
            const [userApiKey, setUserApiKey] = useState(DEFAULT_API_KEY || localStorage.getItem("gemini_api_key") || "");
            const [showKeyModal, setShowKeyModal] = useState(!(DEFAULT_API_KEY || localStorage.getItem("gemini_api_key")));

            const [glossaryItems, setGlossaryItems] = useState(() => {
                try {
                    const saved = localStorage.getItem("gemini_glossary_json");
                    const oldText = localStorage.getItem("gemini_glossary");
                    if (!saved && oldText) {
                        return [{ zh: "Legacy Data", ja: oldText, en: "", abbr: "" }];
                    }
                    return saved ? JSON.parse(saved) : [];
                } catch(e) { return []; }
            });
            const [showGlossaryModal, setShowGlossaryModal] = useState(false);
            
            const [newZh, setNewZh] = useState("");
            const [newJa, setNewJa] = useState("");
            const [newEn, setNewEn] = useState("");
            const [newAbbr, setNewAbbr] = useState("");

            // The model is now determined dynamically inside callGeminiAPI using MODEL_PRIORITY
            const [srcLang, setSrcLang] = useState("en");
            const [auto, setAuto] = useState(true);
            const [autoRefine, setAutoRefine] = useState(false);
            const [src, setSrc] = useState("");
            
            const [visibleMap, setVisibleMap] = useState({ en: false, "zh-TW": false, ja: false });
            const [showViewMenu, setShowViewMenu] = useState(false);

            const [topHeight, setTopHeight] = useState(45);
            const [targetSplit, setTargetSplit] = useState(50);
            const [resizingMode, setResizingMode] = useState(null);

            const [outputs, setOutputs] = useState({ en: "", "zh-TW": "", ja: "" });
            const [busy, setBusy] = useState(false);
            const [refining, setRefining] = useState({ en: false, "zh-TW": false, ja: false });
            const [error, setError] = useState(null);
            const [streaming, setStreaming] = useState(false);

            const controllerRef = useRef(null);
            const menuRef = useRef(null);
            const mainContainerRef = useRef(null);
            const bottomContainerRef = useRef(null);
            const apiKeyInputRef = useRef(null);
            const fileInputRef = useRef(null);
            const translationCacheRef = useRef(new Map());

            const saveApiKey = (key) => {
                const cleanKey = key ? key.trim() : "";
                setUserApiKey(cleanKey);
                localStorage.setItem("gemini_api_key", cleanKey);
                if(cleanKey) setShowKeyModal(false);
            };

            const saveGlossaryItems = (items) => {
                setGlossaryItems(items);
                localStorage.setItem("gemini_glossary_json", JSON.stringify(items));
            };

            const addGlossaryItem = () => {
                if (!newZh && !newJa && !newEn) return;
                const newItem = { zh: newZh, ja: newJa, en: newEn, abbr: newAbbr };
                const updated = [...glossaryItems, newItem];
                saveGlossaryItems(updated);
                setNewZh(""); setNewJa(""); setNewEn(""); setNewAbbr("");
            };

            const removeGlossaryItem = (index) => {
                const updated = glossaryItems.filter((_, i) => i !== index);
                saveGlossaryItems(updated);
            };

            const handleGlossaryImport = (e) => {
                const file = e.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (evt) => {
                    const content = evt.target.result;
                    const lines = content.split(/\r?\n/);
                    const newItems = [];
                    lines.forEach(line => {
                        if(!line.trim()) return;
                        const cols = line.split(/,|，/);
                        if(cols.length > 0) {
                            newItems.push({
                                zh: cols[0]?.trim() || "",
                                ja: cols[1]?.trim() || "",
                                en: cols[2]?.trim() || "",
                                abbr: cols[3]?.trim() || ""
                            });
                        }
                    });
                    saveGlossaryItems([...glossaryItems, ...newItems]);
                };
                reader.readAsText(file);
                e.target.value = ''; 
            };

            useEffect(() => {
                function handleClickOutside(event) {
                    if (menuRef.current && !menuRef.current.contains(event.target)) {
                        setShowViewMenu(false);
                    }
                }
                document.addEventListener("mousedown", handleClickOutside);
                return () => document.removeEventListener("mousedown", handleClickOutside);
            }, []);

            const startResizingVertical = useCallback(() => setResizingMode("vertical"), []);
            const startResizingHorizontal = useCallback(() => setResizingMode("horizontal"), []);
            const stopResizing = useCallback(() => setResizingMode(null), []);

            const resize = useCallback((e) => {
                if (!resizingMode) return;
                if (resizingMode === "vertical" && mainContainerRef.current) {
                    const rect = mainContainerRef.current.getBoundingClientRect();
                    const newHeight = ((e.clientY - rect.top) / rect.height) * 100;
                    if (newHeight > 20 && newHeight < 80) setTopHeight(newHeight);
                } else if (resizingMode === "horizontal" && bottomContainerRef.current) {
                    const rect = bottomContainerRef.current.getBoundingClientRect();
                    const newWidth = ((e.clientX - rect.left) / rect.width) * 100;
                    if (newWidth > 20 && newWidth < 80) setTargetSplit(newWidth);
                }
            }, [resizingMode]);

            useEffect(() => {
                if (resizingMode) {
                    window.addEventListener("mousemove", resize);
                    window.addEventListener("mouseup", stopResizing);
                    window.addEventListener("mouseleave", stopResizing);
                } else {
                    window.removeEventListener("mousemove", resize);
                    window.removeEventListener("mouseup", stopResizing);
                    window.removeEventListener("mouseleave", stopResizing);
                }
                return () => {
                    window.removeEventListener("mousemove", resize);
                    window.removeEventListener("mouseup", stopResizing);
                    window.removeEventListener("mouseleave", stopResizing);
                };
            }, [resizingMode, resize, stopResizing]);

            const activeTargetLangs = useMemo(
                () => ALL_LANGS.filter((l) => l !== srcLang && visibleMap[l]),
                [srcLang, visibleMap]
            );

            useEffect(() => {
                if (!src.trim()) {
                    if (Object.values(visibleMap).some(v => v)) {
                        setVisibleMap({ en: false, "zh-TW": false, ja: false });
                        setOutputs({ en: "", "zh-TW": "", ja: "" });
                    }
                    return;
                }
                const timer = setTimeout(() => {
                    const sample = src.slice(0, 200);
                    const detected = detectLanguage(sample);
                    const hasTargets = Object.values(visibleMap).some(v => v);
                    
                    if (detected !== srcLang || !hasTargets) {
                        setSrcLang(detected);
                        setVisibleMap(prev => {
                            const next = { ...prev };
                            // Auto-activate all other languages
                            ALL_LANGS.forEach(l => { 
                                if (l !== detected) next[l] = true;
                                else next[l] = false;
                            });
                            return next;
                        });
                        if (detected !== srcLang) setOutputs({ en: "", "zh-TW": "", ja: "" });
                    }
                }, 300);
                return () => clearTimeout(timer);
            }, [src, srcLang]);

            useEffect(() => {
                if (!auto) return;
                if (!src.trim()) return;
                if (!userApiKey) return; 
                if (activeTargetLangs.length === 0) return;

                const h = window.setTimeout(() => translate(), 400);
                return () => window.clearTimeout(h);
            }, [src, srcLang, visibleMap, autoRefine, activeTargetLangs.length, userApiKey, glossaryItems]);

            async function callGeminiAPI(promptSystem, promptUser, signal) {
                const keyToUse = userApiKey || DEFAULT_API_KEY;
                if (!keyToUse) throw new Error("API Key is missing");

                let lastError = null;

                // Try models in order of priority
                for (const model of MODEL_PRIORITY) {
                    try {
                        const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${keyToUse}`;
                        const body = {
                            system_instruction: { parts: [{ text: promptSystem }] },
                            contents: [{ role: "user", parts: [{ text: promptUser }] }],
                            generationConfig: {
                                responseMimeType: "application/json",
                                temperature: 0.1,
                                maxOutputTokens: 8192,
                                topP: 0.95,
                                topK: 40
                            },
                        };

                        const res = await fetch(url, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(body),
                            signal,
                        });

                        if (!res.ok) {
                            if (res.status === 429) throw new Error("Too Many Requests (429)");
                            const txt = await res.text();
                            // If it's a 404 (Not Found) or 400 (Bad Request - possibly invalid model), treat it as a reason to try the next model
                            if (res.status === 404 || res.status === 400) {
                                console.warn(`Model ${model} failed with ${res.status}, trying next model.`);
                                throw new Error(`Model ${model} API Error (${res.status}): ${txt}`);
                            }
                            throw new Error(`API Error (${res.status}): ${txt}`);
                        }

                        const data = await res.json();
                        const text = data?.candidates?.[0]?.content?.parts?.[0]?.text;
                        if (!text) throw new Error("No content returned");
                        try { return JSON.parse(text); } catch (e) { throw new Error("Invalid JSON from API"); }

                    } catch (e) {
                        lastError = e;
                        if (e.name === "AbortError") throw e;
                        // Continue to next iteration (fallback model)
                    }
                }
                
                // If all models failed
                throw lastError || new Error("All models failed");
            }

            async function callGeminiAPIStreaming(promptSystem, promptUser, signal, onChunk) {
                const keyToUse = userApiKey || DEFAULT_API_KEY;
                if (!keyToUse) throw new Error("API Key is missing");

                let lastError = null;

                // Try models in order of priority
                for (const model of MODEL_PRIORITY) {
                    try {
                        const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:streamGenerateContent?key=${keyToUse}&alt=sse`;
                        const body = {
                            system_instruction: { parts: [{ text: promptSystem }] },
                            contents: [{ role: "user", parts: [{ text: promptUser }] }],
                            generationConfig: {
                                responseMimeType: "application/json",
                                temperature: 0.1,
                                maxOutputTokens: 8192,
                                topP: 0.95,
                                topK: 40
                            },
                        };

                        const res = await fetch(url, {
                            method: "POST",
                            headers: { "Content-Type": "application/json" },
                            body: JSON.stringify(body),
                            signal,
                        });

                        if (!res.ok) {
                            if (res.status === 429) throw new Error("Too Many Requests (429)");
                            const txt = await res.text();
                            if (res.status === 404 || res.status === 400) {
                                console.warn(`Model ${model} failed with ${res.status}, trying next model.`);
                                throw new Error(`Model ${model} API Error (${res.status}): ${txt}`);
                            }
                            throw new Error(`API Error (${res.status}): ${txt}`);
                        }

                        const reader = res.body.getReader();
                        const decoder = new TextDecoder();
                        let buffer = '';
                        let fullText = '';

                        while (true) {
                            const { done, value } = await reader.read();
                            if (done) break;

                            buffer += decoder.decode(value, { stream: true });
                            const lines = buffer.split('\n');
                            buffer = lines.pop() || '';

                            for (const line of lines) {
                                if (line.startsWith('data: ')) {
                                    const data = line.slice(6);
                                    if (data === '[DONE]') continue;

                                    try {
                                        const parsed = JSON.parse(data);
                                        const text = parsed?.candidates?.[0]?.content?.parts?.[0]?.text;
                                        if (text) {
                                            fullText += text;
                                            if (onChunk) onChunk(fullText);
                                        }
                                    } catch (e) {
                                        // Skip invalid JSON chunks
                                    }
                                }
                            }
                        }

                        if (!fullText) throw new Error("No content returned");
                        try { return JSON.parse(fullText); } catch (e) { throw new Error("Invalid JSON from API"); }

                    } catch (e) {
                        lastError = e;
                        if (e.name === "AbortError") throw e;
                        // Continue to next iteration (fallback model)
                    }
                }

                // If all models failed
                throw lastError || new Error("All models failed");
            }

            async function translate() {
                setError(null);
                if (!src.trim() || activeTargetLangs.length === 0) return;

                if (controllerRef.current) controllerRef.current.abort();
                const controller = new AbortController();
                controllerRef.current = controller;

                // Create cache key
                const glossaryStr = formatGlossaryForPrompt(glossaryItems);
                const cacheKey = JSON.stringify({
                    src: src.trim(),
                    srcLang,
                    targets: activeTargetLangs.sort(),
                    glossary: glossaryStr
                });

                // Check cache
                const cached = translationCacheRef.current.get(cacheKey);
                if (cached) {
                    setOutputs((prev) => ({ ...prev, ...cached }));
                    if (autoRefine) {
                        const tasks = activeTargetLangs
                            .filter(l => cached[l])
                            .map(l => refineOne(l, cached[l], controller.signal));
                        await Promise.all(tasks);
                    }
                    return;
                }

                setBusy(true);
                setStreaming(true);
                setRefining(prev => {
                    const next = { ...prev };
                    activeTargetLangs.forEach(l => next[l] = false);
                    return next;
                });

                try {
                    const systemPrompt = buildMultiSystemPrompt(activeTargetLangs);
                    const userPrompt = buildMultiUserPrompt(src, srcLang, activeTargetLangs, glossaryStr);

                    // Try streaming first, fallback to regular API if it fails
                    let parsed;
                    try {
                        parsed = await callGeminiAPIStreaming(systemPrompt, userPrompt, controller.signal, (partialText) => {
                            try {
                                const partialParsed = JSON.parse(partialText);
                                setOutputs((prev) => ({ ...prev, ...partialParsed }));
                            } catch (e) {
                                // Incomplete JSON, wait for more data
                            }
                        });
                    } catch (streamError) {
                        // Fallback to non-streaming API
                        console.warn("Streaming failed, falling back to regular API:", streamError);
                        parsed = await callGeminiAPI(systemPrompt, userPrompt, controller.signal);
                    }

                    setOutputs((prev) => ({ ...prev, ...parsed }));

                    // Cache the result (limit cache size to 50 entries)
                    if (translationCacheRef.current.size >= 50) {
                        const firstKey = translationCacheRef.current.keys().next().value;
                        translationCacheRef.current.delete(firstKey);
                    }
                    translationCacheRef.current.set(cacheKey, parsed);

                    if (autoRefine) {
                        const tasks = activeTargetLangs
                            .filter(l => parsed[l])
                            .map(l => refineOne(l, parsed[l], controller.signal));
                        await Promise.all(tasks);
                    }
                } catch (e) {
                    if (e.name === "AbortError") return;
                    setError(e.message || "Error");
                } finally {
                    setBusy(false);
                    setStreaming(false);
                }
            }

            async function refineOne(lang, draftOverride, signal) {
                const draft = draftOverride ?? outputs[lang];
                if (!draft) return;
                setRefining((prev) => ({ ...prev, [lang]: true }));
                try {
                    const glossaryStr = formatGlossaryForPrompt(glossaryItems);
                    const systemPrompt = buildRefineSystemPrompt(lang);
                    const userPrompt = buildRefineUserPrompt({ src, srcLang, targetLang: lang, draft, glossary: glossaryStr });
                    const parsed = await callGeminiAPI(systemPrompt, userPrompt, signal);
                    if (parsed && parsed.content) {
                        setOutputs((prev) => ({ ...prev, [lang]: parsed.content }));
                    }
                } catch (e) {
                    if (e.name === "AbortError") return;
                    setError(`Refine Error (${lang}): ${e.message}`);
                } finally {
                    setRefining((prev) => ({ ...prev, [lang]: false }));
                }
            }

            function refineAll() {
                const tasks = activeTargetLangs.filter((l) => !!outputs[l]).map((l) => refineOne(l));
                if (tasks.length === 0) return;
                Promise.all(tasks);
            }

            const isInitialState = activeTargetLangs.length === 0;

            // Global busy state implies either general busy or specific refining
            const anyBusy = busy || Object.values(refining).some(Boolean);

            return (
                <div className="h-screen w-full flex flex-col font-sans overflow-hidden select-none bg-neutral-950 relative">
                    
                    {/* Header */}
                    <header className="flex-none h-16 px-6 border-b border-white/10 bg-neutral-900/80 backdrop-blur-md flex items-center justify-between z-10 relative overflow-hidden">
                        <div className="flex items-center gap-4 relative z-10">
                            <div className="flex items-center gap-2 text-blue-100 font-bold tracking-tight text-2xl">
                                <svg className="w-6 h-6 text-blue-500" fill="none" viewBox="0 0 24 24" stroke="currentColor" strokeWidth="2.5">
                                    <path strokeLinecap="round" strokeLinejoin="round" d="M3 5h12M9 3v2m1.048 9.5A18.022 18.022 0 016.412 9m6.088 9h7M11 21l5-10 5 10M12.751 5C11.783 10.77 8.07 15.61 3 18.129" />
                                </svg>
                                速譯
                            </div>
                        </div>

                        {/* Global Progress Bar */}
                        {anyBusy && (
                            <div className="absolute bottom-0 left-0 w-full h-0.5 bg-neutral-800 overflow-hidden">
                                <div className="w-full h-full bg-gradient-to-r from-transparent via-blue-500 to-transparent animate-loading-bar"></div>
                            </div>
                        )}

                        <div className="flex items-center gap-4 relative z-10">
                            {busy && (
                                <div className="flex items-center gap-2 text-sm font-medium text-blue-400 animate-pulse">
                                    <span className="w-2 h-2 rounded-full bg-blue-400 shadow-[0_0_8px_rgba(96,165,250,0.8)]"></span>
                                    <span className="hidden sm:inline">處理中...</span>
                                </div>
                            )}

                             {/* Glossary Button */}
                             <button 
                                onClick={() => setShowGlossaryModal(true)}
                                className={`p-2 rounded-lg transition-colors flex items-center gap-2 text-sm font-medium ${glossaryItems.length > 0 ? "text-green-300" : "text-neutral-400 hover:text-white hover:bg-white/5"}`}
                                title="詞彙表設定"
                            >
                                <BookIcon />
                                <span className="hidden sm:inline">詞彙表</span>
                            </button>

                             <button 
                                onClick={() => setShowKeyModal(true)}
                                className={`p-2 rounded-lg transition-colors flex items-center gap-2 text-sm font-medium ${!userApiKey && !DEFAULT_API_KEY ? "text-red-400 animate-pulse" : "text-neutral-400 hover:text-white hover:bg-white/5"}`}
                                title="API Key 設定"
                            >
                                <KeyIcon />
                                <span className="hidden sm:inline">{userApiKey || DEFAULT_API_KEY ? "API Key" : "No Key"}</span>
                            </button>

                            <div className="relative" ref={menuRef}>
                                <button 
                                    onClick={() => setShowViewMenu(!showViewMenu)}
                                    className={`p-2 rounded-lg transition-colors flex items-center gap-2 text-sm font-medium ${showViewMenu ? "bg-white/10 text-white" : "text-neutral-400 hover:text-white hover:bg-white/5"}`}
                                >
                                    <EyeIcon />
                                    <span className="hidden sm:inline">顯示</span>
                                </button>
                                {showViewMenu && (
                                    <div className="absolute top-full right-0 mt-2 w-48 bg-neutral-900 border border-white/10 rounded-xl shadow-2xl p-2 z-50">
                                        <div className="text-xs text-neutral-500 px-2 py-1 mb-1 font-medium">顯示語言</div>
                                        {ALL_LANGS.map(lang => (
                                            <label key={lang} className="flex items-center gap-3 px-3 py-2 hover:bg-white/5 rounded cursor-pointer text-base text-neutral-300">
                                                <input type="checkbox" checked={visibleMap[lang]} onChange={(e) => setVisibleMap(prev => ({ ...prev, [lang]: e.target.checked }))} className="w-4 h-4 rounded accent-blue-500 bg-white/10 border-white/20" />
                                                {LANG_LABEL[lang]}
                                            </label>
                                        ))}
                                    </div>
                                )}
                            </div>

                            <div className="h-6 w-px bg-white/10 mx-1 hidden sm:block"></div>

                            <label className="flex items-center gap-2 cursor-pointer text-sm font-medium text-neutral-400 hover:text-white transition-colors">
                                <input type="checkbox" checked={autoRefine} onChange={(e) => setAutoRefine(e.target.checked)} className="w-4 h-4 rounded accent-purple-500 bg-white/10 border-white/20" />
                                <span className="hidden sm:inline">自動潤飾</span>
                            </label>

                            <label className="flex items-center gap-2 cursor-pointer text-sm font-medium text-neutral-400 hover:text-white transition-colors">
                                <input type="checkbox" checked={auto} onChange={(e) => setAuto(e.target.checked)} className="w-4 h-4 rounded accent-blue-500 bg-white/10 border-white/20" />
                                <span className="hidden sm:inline">自動翻譯</span>
                            </label>

                            <button onClick={refineAll} disabled={busy} className="flex items-center gap-2 bg-blue-600 hover:bg-blue-500 text-white text-sm font-medium px-4 py-2 rounded-lg shadow-lg shadow-blue-500/20 disabled:opacity-50 disabled:shadow-none transition-all active:scale-95">
                                <SparklesIcon className="w-5 h-5" />
                                <span className="hidden sm:inline">一鍵潤飾</span>
                                <span className="sm:hidden">潤飾</span>
                            </button>
                        </div>
                    </header>

                    {/* Main Layout */}
                    <main className="flex-1 w-full overflow-hidden flex flex-col" ref={mainContainerRef}>
                        <div style={{ height: isInitialState ? "100%" : `${topHeight}%` }} className="w-full flex flex-col p-3 md:p-4 min-h-[180px] flex-shrink-0 transition-[height] duration-500 ease-in-out">
                            <div className={`flex-1 flex flex-col bg-white/5 rounded-xl border border-white/10 overflow-hidden focus-within:border-blue-500/50 focus-within:ring-1 focus-within:ring-blue-500/20 transition-all duration-300 relative group ${isInitialState ? 'shadow-[0_0_50px_rgba(0,0,0,0.5)]' : ''}`}>
                                <div className="flex-none h-12 px-5 bg-black/20 flex items-center justify-between border-b border-white/5">
                                    <div className="flex items-center gap-4">
                                        <span className="text-xs font-bold text-neutral-500 uppercase tracking-widest select-none">{isInitialState ? "INPUT" : "原文"}</span>
                                        {!isInitialState && (
                                            <div className="flex items-center gap-2 px-3 py-1 rounded-lg border border-white/10 bg-white/5">
                                                <span className="text-base font-medium text-neutral-300">{LANG_LABEL[srcLang]}</span>
                                            </div>
                                        )}
                                    </div>
                                    <div className="flex items-center gap-2">
                                        {!auto && <button onClick={translate} disabled={busy} className="text-xs bg-blue-600 hover:bg-blue-500 text-white px-3 py-1 rounded mr-1 disabled:opacity-50">翻譯</button>}
                                        <button onClick={() => navigator.clipboard.writeText(src)} className="p-2 text-neutral-500 hover:text-white hover:bg-white/10 rounded transition-colors"><CopyIcon /></button>
                                        <button onClick={() => setSrc("")} className="p-2 text-neutral-500 hover:text-red-400 hover:bg-white/10 rounded transition-colors"><TrashIcon /></button>
                                    </div>
                                </div>

                                {/* Prominent Empty State Overlay */}
                                {isInitialState && !src && (
                                    <div className="absolute inset-0 top-10 flex flex-col items-center justify-center pointer-events-none z-10">
                                        <div className="w-24 h-24 text-neutral-600 mb-8 animate-pulse">
                                            <svg fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                                <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="1" d="M11 5H6a2 2 0 00-2 2v11a2 2 0 002 2h11a2 2 0 002-2v-5m-1.414-9.414a2 2 0 112.828 2.828L11.828 15H9v-2.828l8.586-8.586z" />
                                            </svg>
                                        </div>
                                        <p className="text-4xl font-bold text-neutral-400 mb-6 tracking-wider drop-shadow-md">
                                            在此輸入文字
                                        </p>
                                        <div className="flex items-center gap-3 text-neutral-500 bg-black/20 px-6 py-3 rounded-full backdrop-blur-sm">
                                            <span className="w-3 h-3 rounded-full bg-blue-500 animate-pulse"></span>
                                            <span className="text-base">自動偵測語言・即時翻譯</span>
                                        </div>
                                    </div>
                                )}

                                <textarea
                                    value={src}
                                    onChange={(e) => setSrc(e.target.value)}
                                    placeholder={!isInitialState ? "在此輸入或貼上文字..." : ""}
                                    className={`flex-1 w-full resize-none bg-transparent p-6 outline-none leading-relaxed text-neutral-200 placeholder-neutral-600 scrollbar-thin scrollbar-thumb-white/10 scrollbar-track-transparent select-text transition-all duration-500 ${isInitialState ? 'text-3xl md:text-4xl text-center pt-[20vh]' : 'text-xl sm:text-2xl md:text-3xl text-left'}`}
                                    style={{ fontFamily: SERIF_FAMILY }}
                                    spellCheck="false"
                                />
                            </div>
                        </div>

                        {!isInitialState && (
                            <div onMouseDown={startResizingVertical} className={`w-full h-2 hover:h-3 bg-neutral-900 hover:bg-blue-500/50 cursor-row-resize transition-all z-20 flex items-center justify-center group flex-shrink-0 ${resizingMode === "vertical" ? "h-3 bg-blue-500" : ""}`}>
                                <div className="w-12 h-1 bg-neutral-700 group-hover:bg-white rounded-full transition-colors" />
                            </div>
                        )}

                        {!isInitialState && (
                            <div className="flex-1 w-full overflow-hidden p-3 md:p-4 flex animate-in fade-in slide-in-from-bottom-4 duration-500" ref={bottomContainerRef}>
                                {activeTargetLangs.length === 1 && (
                                    <div className="w-full h-full">
                                        <TargetCard lang={activeTargetLangs[0]} value={outputs[activeTargetLangs[0]]} busy={busy} refining={refining[activeTargetLangs[0]]} onRefine={() => refineOne(activeTargetLangs[0])} onClose={() => setVisibleMap(prev => ({...prev, [activeTargetLangs[0]]: false}))} />
                                    </div>
                                )}
                                {activeTargetLangs.length === 2 && (
                                    <>
                                        <div style={{ width: `${targetSplit}%` }} className="h-full pr-2">
                                            <TargetCard lang={activeTargetLangs[0]} value={outputs[activeTargetLangs[0]]} busy={busy} refining={refining[activeTargetLangs[0]]} onRefine={() => refineOne(activeTargetLangs[0])} onClose={() => setVisibleMap(prev => ({...prev, [activeTargetLangs[0]]: false}))} />
                                        </div>
                                        <div onMouseDown={startResizingHorizontal} className={`w-2 hover:w-3 bg-neutral-900 hover:bg-blue-500/50 cursor-col-resize transition-all z-20 flex flex-col items-center justify-center group flex-shrink-0 ${resizingMode === "horizontal" ? "w-3 bg-blue-500" : ""}`}>
                                            <div className="h-12 w-1 bg-neutral-700 group-hover:bg-white rounded-full transition-colors" />
                                        </div>
                                        <div className="flex-1 h-full pl-2">
                                            <TargetCard lang={activeTargetLangs[1]} value={outputs[activeTargetLangs[1]]} busy={busy} refining={refining[activeTargetLangs[1]]} onRefine={() => refineOne(activeTargetLangs[1])} onClose={() => setVisibleMap(prev => ({...prev, [activeTargetLangs[1]]: false}))} />
                                        </div>
                                    </>
                                )}
                                {activeTargetLangs.length >= 3 && (
                                    <div className="grid grid-cols-2 gap-4 w-full h-full overflow-y-auto">
                                        {activeTargetLangs.map((lang, idx) => (
                                            <div key={lang} className={idx === activeTargetLangs.length - 1 && activeTargetLangs.length % 2 !== 0 ? "col-span-2 h-full" : "h-full"}>
                                                <TargetCard lang={lang} value={outputs[lang]} busy={busy} refining={refining[lang]} onRefine={() => refineOne(lang)} onClose={() => setVisibleMap(prev => ({...prev, [lang]: false}))} />
                                            </div>
                                        ))}
                                    </div>
                                )}
                            </div>
                        )}
                    </main>

                    {/* API Key Modal */}
                    {showKeyModal && (
                        <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-6">
                            <div className="bg-neutral-900 border border-white/10 rounded-xl p-8 w-full max-w-lg shadow-2xl">
                                <h3 className="text-2xl font-bold mb-3">API Key Required</h3>
                                <p className="text-base text-neutral-400 mb-6">
                                    使用此應用程式需要 Google Gemini API Key。<br/>
                                    Key 將儲存在瀏覽器的 Local Storage 中。
                                </p>
                                <input 
                                    ref={apiKeyInputRef}
                                    defaultValue={userApiKey}
                                    type="password" 
                                    placeholder="Paste your Gemini API Key here"
                                    className="w-full bg-black/30 border border-white/20 rounded p-4 text-white mb-6 focus:border-blue-500 outline-none text-base"
                                    onKeyDown={(e) => { if(e.key === 'Enter') saveApiKey(apiKeyInputRef.current.value) }}
                                />
                                <div className="flex justify-end gap-3">
                                    {userApiKey && <button onClick={() => setShowKeyModal(false)} className="px-5 py-2.5 text-base text-neutral-400 hover:text-white">關閉</button>}
                                    <button onClick={() => saveApiKey(apiKeyInputRef.current.value)} className="px-5 py-2.5 bg-blue-600 hover:bg-blue-500 text-white rounded font-medium text-base">儲存並開始</button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Glossary Modal (Structured) */}
                    {showGlossaryModal && (
                        <div className="fixed inset-0 bg-black/80 backdrop-blur-sm z-50 flex items-center justify-center p-6">
                            <div className="bg-neutral-900 border border-white/10 rounded-xl p-8 w-full max-w-5xl shadow-2xl flex flex-col max-h-[90vh]">
                                <div className="flex justify-between items-center mb-6">
                                    <h3 className="text-2xl font-bold flex items-center gap-3">
                                        <BookIcon /> 詞彙表設定
                                    </h3>
                                    <button onClick={() => setShowGlossaryModal(false)} className="text-neutral-500 hover:text-white p-2">✕</button>
                                </div>
                                
                                {/* Input Area */}
                                <div className="grid grid-cols-10 gap-3 mb-6 bg-white/5 p-4 rounded-lg">
                                    <input placeholder="繁體中文" value={newZh} onChange={e=>setNewZh(e.target.value)} className="col-span-3 bg-black/30 border border-white/10 rounded px-3 py-2 text-base text-white focus:border-blue-500 outline-none" />
                                    <input placeholder="日文" value={newJa} onChange={e=>setNewJa(e.target.value)} className="col-span-3 bg-black/30 border border-white/10 rounded px-3 py-2 text-base text-white focus:border-blue-500 outline-none" />
                                    <input placeholder="英文" value={newEn} onChange={e=>setNewEn(e.target.value)} className="col-span-2 bg-black/30 border border-white/10 rounded px-3 py-2 text-base text-white focus:border-blue-500 outline-none" />
                                    <input placeholder="縮寫" value={newAbbr} onChange={e=>setNewAbbr(e.target.value)} className="col-span-1 bg-black/30 border border-white/10 rounded px-3 py-2 text-base text-white focus:border-blue-500 outline-none" />
                                    <button onClick={addGlossaryItem} className="col-span-1 bg-blue-600 hover:bg-blue-500 text-white rounded flex items-center justify-center">
                                        <PlusIcon />
                                    </button>
                                </div>

                                {/* List Area */}
                                <div className="flex-1 overflow-y-auto mb-6 border border-white/10 rounded-lg bg-black/20">
                                    {glossaryItems.length === 0 ? (
                                        <div className="p-10 text-center text-neutral-500 text-base">尚未登錄詞彙。</div>
                                    ) : (
                                        <table className="w-full text-left text-base">
                                            <thead className="bg-white/5 sticky top-0 text-neutral-400 text-sm uppercase">
                                                <tr>
                                                    <th className="p-3 font-medium w-3/12">繁體中文</th>
                                                    <th className="p-3 font-medium w-3/12">日文</th>
                                                    <th className="p-3 font-medium w-2/12">英文</th>
                                                    <th className="p-3 font-medium w-1/12">縮寫</th>
                                                    <th className="p-3 font-medium w-1/12 text-center">操作</th>
                                                </tr>
                                            </thead>
                                            <tbody className="divide-y divide-white/5">
                                                {glossaryItems.map((item, idx) => (
                                                    <tr key={idx} className="hover:bg-white/5 transition-colors group">
                                                        <td className="p-3 text-amber-100">{item.zh}</td>
                                                        <td className="p-3 text-emerald-200">{item.ja}</td>
                                                        <td className="p-3 text-sky-200">{item.en}</td>
                                                        <td className="p-3 text-neutral-400">{item.abbr}</td>
                                                        <td className="p-3 text-center">
                                                            <button onClick={() => removeGlossaryItem(idx)} className="text-neutral-600 hover:text-red-400 p-2 rounded hover:bg-white/10 transition-colors">
                                                                <TrashIcon />
                                                            </button>
                                                        </td>
                                                    </tr>
                                                ))}
                                            </tbody>
                                        </table>
                                    )}
                                </div>

                                <div className="flex justify-between items-center">
                                    <label className="flex items-center gap-3 px-4 py-3 bg-white/5 hover:bg-white/10 rounded cursor-pointer text-sm text-neutral-300 transition-colors">
                                        <UploadIcon />
                                        <span>匯入 CSV (中,日,英,縮)</span>
                                        <input 
                                            ref={fileInputRef}
                                            type="file" 
                                            accept=".csv,.txt" 
                                            className="hidden" 
                                            onChange={handleGlossaryImport}
                                        />
                                    </label>
                                    <div className="flex gap-3">
                                        <button onClick={() => saveGlossaryItems([])} className="px-4 py-2.5 text-base text-red-400 hover:text-red-300 hover:bg-white/5 rounded">全部刪除</button>
                                        <button onClick={() => setShowGlossaryModal(false)} className="px-5 py-2.5 bg-blue-600 hover:bg-blue-500 text-white rounded font-medium text-base">完成</button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    )}

                    {error && (
                        <div className="absolute bottom-10 left-1/2 -translate-x-1/2 z-50 bg-red-950/90 backdrop-blur border border-red-500/30 text-red-200 px-6 py-3 rounded-xl text-base shadow-2xl flex items-center gap-3">
                            <span>{error}</span>
                            <button onClick={() => setError(null)} className="ml-2 text-red-400 hover:text-white">✕</button>
                        </div>
                    )}
                </div>
            );
        }

        function TargetCard({ lang, value, busy, refining, onRefine, onClose }) {
            const textColor = LANG_COLOR[lang] || "text-neutral-200";
            const [displayedText, setDisplayedText] = useState("");
            const [isSpeaking, setIsSpeaking] = useState(false);

            useEffect(() => {
                if (!value) {
                    setDisplayedText("");
                    return;
                }
                
                // Streaming effect - optimized for faster display
                let currentIdx = 0;
                const len = value.length;
                const intervalTime = 8;
                const step = Math.max(1, Math.floor(len / 40));

                setDisplayedText("");

                const timer = setInterval(() => {
                    currentIdx += step;
                    if (currentIdx >= len) {
                        setDisplayedText(value);
                        clearInterval(timer);
                    } else {
                        setDisplayedText(value.substring(0, currentIdx));
                    }
                }, intervalTime);

                return () => clearInterval(timer);
            }, [value]);

            const handleSpeak = () => {
                if (!value) return;

                if (isSpeaking) {
                    window.speechSynthesis.cancel();
                    setIsSpeaking(false);
                } else {
                    window.speechSynthesis.cancel();
                    const utterance = new SpeechSynthesisUtterance(value);
                    const langMap = { "en": "en-US", "zh-TW": "zh-TW", "ja": "ja-JP" };
                    utterance.lang = langMap[lang] || "en-US";
                    
                    utterance.onend = () => setIsSpeaking(false);
                    utterance.onerror = () => setIsSpeaking(false);
                    
                    window.speechSynthesis.speak(utterance);
                    setIsSpeaking(true);
                }
            };

            // Cleanup when component unmounts
            useEffect(() => {
                return () => {
                    if (isSpeaking) window.speechSynthesis.cancel();
                };
            }, [isSpeaking]);

            // Stop speaking if text changes
            useEffect(() => {
                setIsSpeaking(false);
                window.speechSynthesis.cancel();
            }, [value]);

            // Determine if this specific card is waiting for data (Busy but no value yet)
            const isWaitingForTranslation = busy && !value && !refining;

            return (
                <div className="flex flex-col h-full bg-white/5 rounded-xl border border-white/10 overflow-hidden hover:border-white/20 transition-colors relative group">
                    {/* Refining Overlay */}
                    {refining && (
                        <div className="absolute inset-0 z-20 bg-black/60 backdrop-blur-[2px] flex flex-col items-center justify-center animate-in fade-in duration-300">
                            <LoadingSpinner />
                            <span className="mt-4 text-base font-medium text-blue-200 tracking-wider">AI 潤飾中...</span>
                        </div>
                    )}
                    
                    <div className="flex-none h-12 px-4 bg-black/20 flex items-center justify-between border-b border-white/5">
                        <span className={`text-base font-bold ${textColor} brightness-110`}>{LANG_LABEL[lang]}</span>
                        <div className="flex items-center gap-2 opacity-0 group-hover:opacity-100 transition-opacity">
                            <button 
                                onClick={handleSpeak} 
                                disabled={!value} 
                                className={`p-2 hover:text-white transition-colors ${isSpeaking ? "text-green-400 animate-pulse" : "text-neutral-500"}`} 
                                title={isSpeaking ? "停止" : "朗讀"}
                            >
                                {isSpeaking ? <StopIcon /> : <SpeakerIcon />}
                            </button>
                            <button onClick={onRefine} disabled={!value || busy || refining} className={`p-2 rounded ${refining ? "text-blue-400" : "text-neutral-500 hover:text-blue-300"}`} title="潤飾"><SparklesIcon className="w-5 h-5" /></button>
                            <button onClick={() => navigator.clipboard.writeText(value)} disabled={!value} className="p-2 text-neutral-500 hover:text-white" title="複製"><CopyIcon /></button>
                            <button onClick={onClose} className="p-2 text-neutral-500 hover:text-red-400 ml-1" title="隱藏">✕</button>
                        </div>
                    </div>
                    <div className={`flex-1 w-full p-6 overflow-y-auto text-2xl sm:text-3xl leading-relaxed ${textColor} font-serif-custom select-text`}>
                        {isWaitingForTranslation ? (
                            <SkeletonLoader />
                        ) : (
                            value ? displayedText : null
                        )}
                    </div>
                </div>
            );
        }

        // Prompts
        function buildMultiSystemPrompt(targets) {
            return `You are a professional translator. Translate user text into: ${targets.join(", ")}. Return a single valid JSON object ONLY. Keys: ${targets.map(t=>`"${t}"`).join(", ")}. Values: translated text. 
STRICT FORMATTING RULES:
1. PRESERVE LINE COUNT: If source has N lines, output MUST have N lines.
2. LINE-BY-LINE MAPPING: Line 1 of source maps to Line 1 of target. Line 2 to Line 2, etc.
3. PRESERVE EMPTY LINES: Do not skip or remove empty lines.
4. Do NOT merge paragraphs.
5. Do NOT add markdown code blocks unless present in source.`;
        }

        function buildMultiUserPrompt(text, srcLang, targets, glossary) {
            // 計算原文行數 (包含空行)
            const lines = text.split(/\r\n|\r|\n/);
            const lineCount = lines.length;

            let prompt = `Source Language: ${srcLang}\nTarget Languages: ${targets.join(", ")}\n`;
            
            // 強制行數約束
            prompt += `\n[CRITICAL CONSTRAINT]: The source text contains exactly ${lineCount} lines. Your translation MUST contain exactly ${lineCount} lines. Check your output line by line to ensure it matches.\n`;

            if (glossary && glossary.trim()) {
                prompt += `\n[Glossary]:\n${glossary}\n`;
            }
            
            prompt += `\nSource Text:\n${text}`;
            return prompt;
        }

        function buildRefineSystemPrompt(target) {
            return `You are a professional editor. Refine the translation into ${target} to be natural and accurate. Return JSON: { "content": "refined text" }.
STRICT FORMATTING RULES:
1. PRESERVE LINE COUNT: The output MUST have the EXACT SAME number of lines as the draft.
2. No merging or splitting lines.
3. Keep empty lines exactly as they are.`;
        }

        function buildRefineUserPrompt({ src, srcLang, targetLang, draft, glossary }) {
            // 計算草稿行數
            const lines = draft.split(/\r\n|\r|\n/);
            const lineCount = lines.length;

            let prompt = `Original (${srcLang}):\n${src}\n\nDraft (${targetLang}):\n${draft}\n`;
            
            // 強制行數約束
            prompt += `\n[CRITICAL CONSTRAINT]: The Draft text has ${lineCount} lines. Your refined output MUST have exactly ${lineCount} lines. Do not add or remove lines.\n`;

            if (glossary && glossary.trim()) {
                prompt += `\n[Glossary Check]:\n${glossary}\n`;
            }
            
            prompt += `\nRefine the draft text while strictly preserving the line structure.`;
            return prompt;
        }

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
